/* raw-gamepad-monitor.c generated by valac 0.32.0.45-49b63, the Vala compiler
 * generated from raw-gamepad-monitor.vala, do not modify */

/* This file is part of GNOME Games. License: GPLv3*/

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gudev/gudev.h>


#define LIB_GAMEPAD_TYPE_RAW_GAMEPAD_MONITOR (lib_gamepad_raw_gamepad_monitor_get_type ())
#define LIB_GAMEPAD_RAW_GAMEPAD_MONITOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), LIB_GAMEPAD_TYPE_RAW_GAMEPAD_MONITOR, LibGamepadRawGamepadMonitor))
#define LIB_GAMEPAD_IS_RAW_GAMEPAD_MONITOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), LIB_GAMEPAD_TYPE_RAW_GAMEPAD_MONITOR))
#define LIB_GAMEPAD_RAW_GAMEPAD_MONITOR_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), LIB_GAMEPAD_TYPE_RAW_GAMEPAD_MONITOR, LibGamepadRawGamepadMonitorIface))

typedef struct _LibGamepadRawGamepadMonitor LibGamepadRawGamepadMonitor;
typedef struct _LibGamepadRawGamepadMonitorIface LibGamepadRawGamepadMonitorIface;

#define LIB_GAMEPAD_TYPE_RAW_GAMEPAD (lib_gamepad_raw_gamepad_get_type ())
#define LIB_GAMEPAD_RAW_GAMEPAD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), LIB_GAMEPAD_TYPE_RAW_GAMEPAD, LibGamepadRawGamepad))
#define LIB_GAMEPAD_IS_RAW_GAMEPAD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), LIB_GAMEPAD_TYPE_RAW_GAMEPAD))
#define LIB_GAMEPAD_RAW_GAMEPAD_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), LIB_GAMEPAD_TYPE_RAW_GAMEPAD, LibGamepadRawGamepadIface))

typedef struct _LibGamepadRawGamepad LibGamepadRawGamepad;
typedef struct _LibGamepadRawGamepadIface LibGamepadRawGamepadIface;

#define LIB_GAMEPAD_TYPE_LINUX_RAW_GAMEPAD_MONITOR (lib_gamepad_linux_raw_gamepad_monitor_get_type ())
#define LIB_GAMEPAD_LINUX_RAW_GAMEPAD_MONITOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), LIB_GAMEPAD_TYPE_LINUX_RAW_GAMEPAD_MONITOR, LibGamepadLinuxRawGamepadMonitor))
#define LIB_GAMEPAD_LINUX_RAW_GAMEPAD_MONITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), LIB_GAMEPAD_TYPE_LINUX_RAW_GAMEPAD_MONITOR, LibGamepadLinuxRawGamepadMonitorClass))
#define LIB_GAMEPAD_IS_LINUX_RAW_GAMEPAD_MONITOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), LIB_GAMEPAD_TYPE_LINUX_RAW_GAMEPAD_MONITOR))
#define LIB_GAMEPAD_IS_LINUX_RAW_GAMEPAD_MONITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), LIB_GAMEPAD_TYPE_LINUX_RAW_GAMEPAD_MONITOR))
#define LIB_GAMEPAD_LINUX_RAW_GAMEPAD_MONITOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), LIB_GAMEPAD_TYPE_LINUX_RAW_GAMEPAD_MONITOR, LibGamepadLinuxRawGamepadMonitorClass))

typedef struct _LibGamepadLinuxRawGamepadMonitor LibGamepadLinuxRawGamepadMonitor;
typedef struct _LibGamepadLinuxRawGamepadMonitorClass LibGamepadLinuxRawGamepadMonitorClass;
typedef struct _LibGamepadLinuxRawGamepadMonitorPrivate LibGamepadLinuxRawGamepadMonitorPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))

#define LIB_GAMEPAD_TYPE_LINUX_RAW_GAMEPAD (lib_gamepad_linux_raw_gamepad_get_type ())
#define LIB_GAMEPAD_LINUX_RAW_GAMEPAD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), LIB_GAMEPAD_TYPE_LINUX_RAW_GAMEPAD, LibGamepadLinuxRawGamepad))
#define LIB_GAMEPAD_LINUX_RAW_GAMEPAD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), LIB_GAMEPAD_TYPE_LINUX_RAW_GAMEPAD, LibGamepadLinuxRawGamepadClass))
#define LIB_GAMEPAD_IS_LINUX_RAW_GAMEPAD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), LIB_GAMEPAD_TYPE_LINUX_RAW_GAMEPAD))
#define LIB_GAMEPAD_IS_LINUX_RAW_GAMEPAD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), LIB_GAMEPAD_TYPE_LINUX_RAW_GAMEPAD))
#define LIB_GAMEPAD_LINUX_RAW_GAMEPAD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), LIB_GAMEPAD_TYPE_LINUX_RAW_GAMEPAD, LibGamepadLinuxRawGamepadClass))

typedef struct _LibGamepadLinuxRawGamepad LibGamepadLinuxRawGamepad;
typedef struct _LibGamepadLinuxRawGamepadClass LibGamepadLinuxRawGamepadClass;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define __g_list_free__g_object_unref0_0(var) ((var == NULL) ? NULL : (var = (_g_list_free__g_object_unref0_ (var), NULL)))
typedef struct _Block1Data Block1Data;

struct _LibGamepadRawGamepadIface {
	GTypeInterface parent_iface;
	const gchar* (*get_identifier) (LibGamepadRawGamepad* self);
	const gchar* (*get_name) (LibGamepadRawGamepad* self);
	const gchar* (*get_guid) (LibGamepadRawGamepad* self);
	guint8 (*get_axes_number) (LibGamepadRawGamepad* self);
	guint8 (*get_buttons_number) (LibGamepadRawGamepad* self);
	guint8 (*get_dpads_number) (LibGamepadRawGamepad* self);
};

typedef void (*LibGamepadRawGamepadMonitorRawGamepadCallback) (LibGamepadRawGamepad* raw_gamepad, void* user_data);
struct _LibGamepadRawGamepadMonitorIface {
	GTypeInterface parent_iface;
	void (*foreach_gamepad) (LibGamepadRawGamepadMonitor* self, LibGamepadRawGamepadMonitorRawGamepadCallback callback, void* callback_target);
};

struct _LibGamepadLinuxRawGamepadMonitor {
	GObject parent_instance;
	LibGamepadLinuxRawGamepadMonitorPrivate * priv;
};

struct _LibGamepadLinuxRawGamepadMonitorClass {
	GObjectClass parent_class;
};

struct _LibGamepadLinuxRawGamepadMonitorPrivate {
	GUdevClient* client;
	GHashTable* raw_gamepads;
};

typedef void (*LibGamepadLinuxRawGamepadMonitorRawGamepadCallback) (LibGamepadRawGamepad* raw_gamepad, void* user_data);
struct _Block1Data {
	int _ref_count_;
	LibGamepadLinuxRawGamepadMonitor* self;
	LibGamepadLinuxRawGamepadMonitorRawGamepadCallback callback;
	gpointer callback_target;
};


static gpointer lib_gamepad_linux_raw_gamepad_monitor_parent_class = NULL;
static LibGamepadRawGamepadMonitorIface* lib_gamepad_linux_raw_gamepad_monitor_lib_gamepad_raw_gamepad_monitor_parent_iface = NULL;

GType lib_gamepad_raw_gamepad_get_type (void) G_GNUC_CONST;
GType lib_gamepad_raw_gamepad_monitor_get_type (void) G_GNUC_CONST;
GType lib_gamepad_linux_raw_gamepad_monitor_get_type (void) G_GNUC_CONST;
#define LIB_GAMEPAD_LINUX_RAW_GAMEPAD_MONITOR_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), LIB_GAMEPAD_TYPE_LINUX_RAW_GAMEPAD_MONITOR, LibGamepadLinuxRawGamepadMonitorPrivate))
enum  {
	LIB_GAMEPAD_LINUX_RAW_GAMEPAD_MONITOR_DUMMY_PROPERTY
};
LibGamepadLinuxRawGamepadMonitor* lib_gamepad_linux_raw_gamepad_monitor_new (void);
LibGamepadLinuxRawGamepadMonitor* lib_gamepad_linux_raw_gamepad_monitor_construct (GType object_type);
static void lib_gamepad_linux_raw_gamepad_monitor_handle_udev_client_callback (LibGamepadLinuxRawGamepadMonitor* self, const gchar* action, GUdevDevice* dev);
static void _lib_gamepad_linux_raw_gamepad_monitor_handle_udev_client_callback_g_udev_client_uevent (GUdevClient* _sender, const gchar* action, GUdevDevice* device, gpointer self);
static void __lambda5_ (LibGamepadLinuxRawGamepadMonitor* self, GUdevDevice* dev);
GType lib_gamepad_linux_raw_gamepad_get_type (void) G_GNUC_CONST;
LibGamepadLinuxRawGamepad* lib_gamepad_linux_raw_gamepad_new (const gchar* file_name, GError** error);
LibGamepadLinuxRawGamepad* lib_gamepad_linux_raw_gamepad_construct (GType object_type, const gchar* file_name, GError** error);
static void ___lambda5__gfunc (gconstpointer data, gpointer self);
static void _g_object_unref0_ (gpointer var);
static void _g_list_free__g_object_unref0_ (GList* self);
static void lib_gamepad_linux_raw_gamepad_monitor_real_foreach_gamepad (LibGamepadRawGamepadMonitor* base, LibGamepadLinuxRawGamepadMonitorRawGamepadCallback callback, void* callback_target);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static void __lambda6_ (Block1Data* _data1_, const gchar* identifier, LibGamepadRawGamepad* raw_gamepad);
static void ___lambda6__gh_func (gconstpointer key, gconstpointer value, gpointer self);
static void lib_gamepad_linux_raw_gamepad_monitor_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


static void _lib_gamepad_linux_raw_gamepad_monitor_handle_udev_client_callback_g_udev_client_uevent (GUdevClient* _sender, const gchar* action, GUdevDevice* device, gpointer self) {
	lib_gamepad_linux_raw_gamepad_monitor_handle_udev_client_callback ((LibGamepadLinuxRawGamepadMonitor*) self, action, device);
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void __lambda5_ (LibGamepadLinuxRawGamepadMonitor* self, GUdevDevice* dev) {
	GUdevDevice* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gchar* identifier = NULL;
	GUdevDevice* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp6_ = FALSE;
	GUdevDevice* _tmp7_ = NULL;
	gboolean _tmp8_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_if_fail (dev != NULL);
	_tmp0_ = dev;
	_tmp1_ = g_udev_device_get_device_file (_tmp0_);
	if (_tmp1_ == NULL) {
		return;
	}
	_tmp2_ = dev;
	_tmp3_ = g_udev_device_get_device_file (_tmp2_);
	_tmp4_ = g_strdup (_tmp3_);
	identifier = _tmp4_;
	_tmp7_ = dev;
	_tmp8_ = g_udev_device_has_property (_tmp7_, "ID_INPUT_JOYSTICK");
	if (_tmp8_) {
		GUdevDevice* _tmp9_ = NULL;
		const gchar* _tmp10_ = NULL;
		_tmp9_ = dev;
		_tmp10_ = g_udev_device_get_property (_tmp9_, "ID_INPUT_JOYSTICK");
		_tmp6_ = g_strcmp0 (_tmp10_, "1") == 0;
	} else {
		_tmp6_ = FALSE;
	}
	if (_tmp6_) {
		_tmp5_ = TRUE;
	} else {
		gboolean _tmp11_ = FALSE;
		GUdevDevice* _tmp12_ = NULL;
		gboolean _tmp13_ = FALSE;
		_tmp12_ = dev;
		_tmp13_ = g_udev_device_has_property (_tmp12_, ".INPUT_CLASS");
		if (_tmp13_) {
			GUdevDevice* _tmp14_ = NULL;
			const gchar* _tmp15_ = NULL;
			_tmp14_ = dev;
			_tmp15_ = g_udev_device_get_property (_tmp14_, ".INPUT_CLASS");
			_tmp11_ = g_strcmp0 (_tmp15_, "joystick") == 0;
		} else {
			_tmp11_ = FALSE;
		}
		_tmp5_ = _tmp11_;
	}
	if (_tmp5_) {
		LibGamepadRawGamepad* raw_gamepad = NULL;
		GHashTable* _tmp20_ = NULL;
		const gchar* _tmp21_ = NULL;
		gchar* _tmp22_ = NULL;
		LibGamepadRawGamepad* _tmp23_ = NULL;
		LibGamepadRawGamepad* _tmp24_ = NULL;
		{
			LibGamepadLinuxRawGamepad* _tmp16_ = NULL;
			const gchar* _tmp17_ = NULL;
			LibGamepadLinuxRawGamepad* _tmp18_ = NULL;
			LibGamepadLinuxRawGamepad* _tmp19_ = NULL;
			_tmp17_ = identifier;
			_tmp18_ = lib_gamepad_linux_raw_gamepad_new (_tmp17_, &_inner_error_);
			_tmp16_ = _tmp18_;
			if (G_UNLIKELY (_inner_error_ != NULL)) {
				if (_inner_error_->domain == G_FILE_ERROR) {
					goto __catch3_g_file_error;
				}
				_g_object_unref0 (raw_gamepad);
				_g_free0 (identifier);
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
			_tmp19_ = _tmp16_;
			_tmp16_ = NULL;
			_g_object_unref0 (raw_gamepad);
			raw_gamepad = (LibGamepadRawGamepad*) _tmp19_;
			_g_object_unref0 (_tmp16_);
		}
		goto __finally3;
		__catch3_g_file_error:
		{
			GError* err = NULL;
			err = _inner_error_;
			_inner_error_ = NULL;
			_g_error_free0 (err);
			_g_object_unref0 (raw_gamepad);
			_g_free0 (identifier);
			return;
		}
		__finally3:
		if (G_UNLIKELY (_inner_error_ != NULL)) {
			_g_object_unref0 (raw_gamepad);
			_g_free0 (identifier);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		_tmp20_ = self->priv->raw_gamepads;
		_tmp21_ = identifier;
		_tmp22_ = g_strdup (_tmp21_);
		_tmp23_ = raw_gamepad;
		_tmp24_ = _g_object_ref0 (_tmp23_);
		g_hash_table_replace (_tmp20_, _tmp22_, _tmp24_);
		_g_object_unref0 (raw_gamepad);
	}
	_g_free0 (identifier);
}


static void ___lambda5__gfunc (gconstpointer data, gpointer self) {
	__lambda5_ ((LibGamepadLinuxRawGamepadMonitor*) self, (GUdevDevice*) data);
}


static void _g_object_unref0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (g_object_unref (var), NULL));
}


static void _g_list_free__g_object_unref0_ (GList* self) {
	g_list_foreach (self, (GFunc) _g_object_unref0_, NULL);
	g_list_free (self);
}


LibGamepadLinuxRawGamepadMonitor* lib_gamepad_linux_raw_gamepad_monitor_construct (GType object_type) {
	LibGamepadLinuxRawGamepadMonitor * self = NULL;
	gchar* _tmp0_ = NULL;
	gchar** _tmp1_ = NULL;
	gchar** _tmp2_ = NULL;
	gint _tmp2__length1 = 0;
	GUdevClient* _tmp3_ = NULL;
	GUdevClient* _tmp4_ = NULL;
	GUdevClient* _tmp5_ = NULL;
	GList* _tmp6_ = NULL;
	GList* _tmp7_ = NULL;
	self = (LibGamepadLinuxRawGamepadMonitor*) g_object_new (object_type, NULL);
	_tmp0_ = g_strdup ("input");
	_tmp1_ = g_new0 (gchar*, 1 + 1);
	_tmp1_[0] = _tmp0_;
	_tmp2_ = _tmp1_;
	_tmp2__length1 = 1;
	_tmp3_ = g_udev_client_new (_tmp2_);
	_g_object_unref0 (self->priv->client);
	self->priv->client = _tmp3_;
	_tmp2_ = (_vala_array_free (_tmp2_, _tmp2__length1, (GDestroyNotify) g_free), NULL);
	_tmp4_ = self->priv->client;
	g_signal_connect_object (_tmp4_, "uevent", (GCallback) _lib_gamepad_linux_raw_gamepad_monitor_handle_udev_client_callback_g_udev_client_uevent, self, 0);
	_tmp5_ = self->priv->client;
	_tmp6_ = g_udev_client_query_by_subsystem (_tmp5_, "input");
	_tmp7_ = _tmp6_;
	g_list_foreach (_tmp7_, ___lambda5__gfunc, self);
	__g_list_free__g_object_unref0_0 (_tmp7_);
	return self;
}


LibGamepadLinuxRawGamepadMonitor* lib_gamepad_linux_raw_gamepad_monitor_new (void) {
	return lib_gamepad_linux_raw_gamepad_monitor_construct (LIB_GAMEPAD_TYPE_LINUX_RAW_GAMEPAD_MONITOR);
}


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (void * _userdata_) {
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		LibGamepadLinuxRawGamepadMonitor* self;
		self = _data1_->self;
		_g_object_unref0 (self);
		g_slice_free (Block1Data, _data1_);
	}
}


static void __lambda6_ (Block1Data* _data1_, const gchar* identifier, LibGamepadRawGamepad* raw_gamepad) {
	LibGamepadLinuxRawGamepadMonitor* self;
	LibGamepadLinuxRawGamepadMonitorRawGamepadCallback _tmp0_ = NULL;
	void* _tmp0__target = NULL;
	LibGamepadRawGamepad* _tmp1_ = NULL;
	self = _data1_->self;
	g_return_if_fail (identifier != NULL);
	g_return_if_fail (raw_gamepad != NULL);
	_tmp0_ = _data1_->callback;
	_tmp0__target = _data1_->callback_target;
	_tmp1_ = raw_gamepad;
	_tmp0_ (_tmp1_, _tmp0__target);
}


static void ___lambda6__gh_func (gconstpointer key, gconstpointer value, gpointer self) {
	__lambda6_ (self, (const gchar*) key, (LibGamepadRawGamepad*) value);
}


static void lib_gamepad_linux_raw_gamepad_monitor_real_foreach_gamepad (LibGamepadRawGamepadMonitor* base, LibGamepadLinuxRawGamepadMonitorRawGamepadCallback callback, void* callback_target) {
	LibGamepadLinuxRawGamepadMonitor * self;
	Block1Data* _data1_;
	LibGamepadLinuxRawGamepadMonitorRawGamepadCallback _tmp0_ = NULL;
	void* _tmp0__target = NULL;
	GHashTable* _tmp1_ = NULL;
	self = (LibGamepadLinuxRawGamepadMonitor*) base;
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	_data1_->self = g_object_ref (self);
	_tmp0_ = callback;
	_tmp0__target = callback_target;
	_data1_->callback = _tmp0_;
	_data1_->callback_target = _tmp0__target;
	_tmp1_ = self->priv->raw_gamepads;
	g_hash_table_foreach (_tmp1_, ___lambda6__gh_func, _data1_);
	block1_data_unref (_data1_);
	_data1_ = NULL;
}


static void lib_gamepad_linux_raw_gamepad_monitor_handle_udev_client_callback (LibGamepadLinuxRawGamepadMonitor* self, const gchar* action, GUdevDevice* dev) {
	GUdevDevice* _tmp0_ = NULL;
	const gchar* _tmp1_ = NULL;
	gchar* identifier = NULL;
	GUdevDevice* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp6_ = FALSE;
	GUdevDevice* _tmp7_ = NULL;
	gboolean _tmp8_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (action != NULL);
	g_return_if_fail (dev != NULL);
	_tmp0_ = dev;
	_tmp1_ = g_udev_device_get_device_file (_tmp0_);
	if (_tmp1_ == NULL) {
		return;
	}
	_tmp2_ = dev;
	_tmp3_ = g_udev_device_get_device_file (_tmp2_);
	_tmp4_ = g_strdup (_tmp3_);
	identifier = _tmp4_;
	_tmp7_ = dev;
	_tmp8_ = g_udev_device_has_property (_tmp7_, "ID_INPUT_JOYSTICK");
	if (_tmp8_) {
		GUdevDevice* _tmp9_ = NULL;
		const gchar* _tmp10_ = NULL;
		_tmp9_ = dev;
		_tmp10_ = g_udev_device_get_property (_tmp9_, "ID_INPUT_JOYSTICK");
		_tmp6_ = g_strcmp0 (_tmp10_, "1") == 0;
	} else {
		_tmp6_ = FALSE;
	}
	if (_tmp6_) {
		_tmp5_ = TRUE;
	} else {
		gboolean _tmp11_ = FALSE;
		GUdevDevice* _tmp12_ = NULL;
		gboolean _tmp13_ = FALSE;
		_tmp12_ = dev;
		_tmp13_ = g_udev_device_has_property (_tmp12_, ".INPUT_CLASS");
		if (_tmp13_) {
			GUdevDevice* _tmp14_ = NULL;
			const gchar* _tmp15_ = NULL;
			_tmp14_ = dev;
			_tmp15_ = g_udev_device_get_property (_tmp14_, ".INPUT_CLASS");
			_tmp11_ = g_strcmp0 (_tmp15_, "joystick") == 0;
		} else {
			_tmp11_ = FALSE;
		}
		_tmp5_ = _tmp11_;
	}
	if (_tmp5_) {
		const gchar* _tmp16_ = NULL;
		const gchar* _tmp17_ = NULL;
		GQuark _tmp19_ = 0U;
		static GQuark _tmp18_label0 = 0;
		static GQuark _tmp18_label1 = 0;
		_tmp16_ = action;
		_tmp17_ = _tmp16_;
		_tmp19_ = (NULL == _tmp17_) ? 0 : g_quark_from_string (_tmp17_);
		if (_tmp19_ == ((0 != _tmp18_label0) ? _tmp18_label0 : (_tmp18_label0 = g_quark_from_static_string ("add")))) {
			switch (0) {
				default:
				{
					LibGamepadRawGamepad* raw_gamepad = NULL;
					GHashTable* _tmp24_ = NULL;
					const gchar* _tmp25_ = NULL;
					gchar* _tmp26_ = NULL;
					LibGamepadRawGamepad* _tmp27_ = NULL;
					LibGamepadRawGamepad* _tmp28_ = NULL;
					LibGamepadRawGamepad* _tmp29_ = NULL;
					{
						LibGamepadLinuxRawGamepad* _tmp20_ = NULL;
						const gchar* _tmp21_ = NULL;
						LibGamepadLinuxRawGamepad* _tmp22_ = NULL;
						LibGamepadLinuxRawGamepad* _tmp23_ = NULL;
						_tmp21_ = identifier;
						_tmp22_ = lib_gamepad_linux_raw_gamepad_new (_tmp21_, &_inner_error_);
						_tmp20_ = _tmp22_;
						if (G_UNLIKELY (_inner_error_ != NULL)) {
							if (_inner_error_->domain == G_FILE_ERROR) {
								goto __catch4_g_file_error;
							}
							_g_object_unref0 (raw_gamepad);
							_g_free0 (identifier);
							g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return;
						}
						_tmp23_ = _tmp20_;
						_tmp20_ = NULL;
						_g_object_unref0 (raw_gamepad);
						raw_gamepad = (LibGamepadRawGamepad*) _tmp23_;
						_g_object_unref0 (_tmp20_);
					}
					goto __finally4;
					__catch4_g_file_error:
					{
						GError* err = NULL;
						err = _inner_error_;
						_inner_error_ = NULL;
						_g_error_free0 (err);
						_g_object_unref0 (raw_gamepad);
						_g_free0 (identifier);
						return;
					}
					__finally4:
					if (G_UNLIKELY (_inner_error_ != NULL)) {
						_g_object_unref0 (raw_gamepad);
						_g_free0 (identifier);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					_tmp24_ = self->priv->raw_gamepads;
					_tmp25_ = identifier;
					_tmp26_ = g_strdup (_tmp25_);
					_tmp27_ = raw_gamepad;
					_tmp28_ = _g_object_ref0 (_tmp27_);
					g_hash_table_replace (_tmp24_, _tmp26_, _tmp28_);
					_tmp29_ = raw_gamepad;
					g_signal_emit_by_name ((LibGamepadRawGamepadMonitor*) self, "gamepad-plugged", _tmp29_);
					_g_object_unref0 (raw_gamepad);
					break;
				}
			}
		} else if (_tmp19_ == ((0 != _tmp18_label1) ? _tmp18_label1 : (_tmp18_label1 = g_quark_from_static_string ("remove")))) {
			switch (0) {
				default:
				{
					GHashTable* _tmp30_ = NULL;
					const gchar* _tmp31_ = NULL;
					gboolean _tmp32_ = FALSE;
					LibGamepadRawGamepad* raw_gamepad = NULL;
					GHashTable* _tmp33_ = NULL;
					const gchar* _tmp34_ = NULL;
					gconstpointer _tmp35_ = NULL;
					LibGamepadRawGamepad* _tmp36_ = NULL;
					GHashTable* _tmp37_ = NULL;
					const gchar* _tmp38_ = NULL;
					LibGamepadRawGamepad* _tmp39_ = NULL;
					LibGamepadRawGamepad* _tmp40_ = NULL;
					_tmp30_ = self->priv->raw_gamepads;
					_tmp31_ = identifier;
					_tmp32_ = g_hash_table_contains (_tmp30_, _tmp31_);
					if (!_tmp32_) {
						break;
					}
					_tmp33_ = self->priv->raw_gamepads;
					_tmp34_ = identifier;
					_tmp35_ = g_hash_table_lookup (_tmp33_, _tmp34_);
					_tmp36_ = _g_object_ref0 ((LibGamepadRawGamepad*) _tmp35_);
					raw_gamepad = _tmp36_;
					_tmp37_ = self->priv->raw_gamepads;
					_tmp38_ = identifier;
					g_hash_table_remove (_tmp37_, _tmp38_);
					_tmp39_ = raw_gamepad;
					g_signal_emit_by_name (_tmp39_, "unplugged");
					_tmp40_ = raw_gamepad;
					g_signal_emit_by_name ((LibGamepadRawGamepadMonitor*) self, "gamepad-unplugged", _tmp40_);
					_g_object_unref0 (raw_gamepad);
					break;
				}
			}
		}
	}
	_g_free0 (identifier);
}


static void lib_gamepad_linux_raw_gamepad_monitor_class_init (LibGamepadLinuxRawGamepadMonitorClass * klass) {
	lib_gamepad_linux_raw_gamepad_monitor_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (LibGamepadLinuxRawGamepadMonitorPrivate));
	G_OBJECT_CLASS (klass)->finalize = lib_gamepad_linux_raw_gamepad_monitor_finalize;
}


static void lib_gamepad_linux_raw_gamepad_monitor_lib_gamepad_raw_gamepad_monitor_interface_init (LibGamepadRawGamepadMonitorIface * iface) {
	lib_gamepad_linux_raw_gamepad_monitor_lib_gamepad_raw_gamepad_monitor_parent_iface = g_type_interface_peek_parent (iface);
	iface->foreach_gamepad = (void (*)(LibGamepadRawGamepadMonitor*, LibGamepadRawGamepadMonitorRawGamepadCallback, void*)) lib_gamepad_linux_raw_gamepad_monitor_real_foreach_gamepad;
}


static void lib_gamepad_linux_raw_gamepad_monitor_instance_init (LibGamepadLinuxRawGamepadMonitor * self) {
	self->priv = LIB_GAMEPAD_LINUX_RAW_GAMEPAD_MONITOR_GET_PRIVATE (self);
}


static void lib_gamepad_linux_raw_gamepad_monitor_finalize (GObject* obj) {
	LibGamepadLinuxRawGamepadMonitor * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, LIB_GAMEPAD_TYPE_LINUX_RAW_GAMEPAD_MONITOR, LibGamepadLinuxRawGamepadMonitor);
	_g_object_unref0 (self->priv->client);
	_g_hash_table_unref0 (self->priv->raw_gamepads);
	G_OBJECT_CLASS (lib_gamepad_linux_raw_gamepad_monitor_parent_class)->finalize (obj);
}


GType lib_gamepad_linux_raw_gamepad_monitor_get_type (void) {
	static volatile gsize lib_gamepad_linux_raw_gamepad_monitor_type_id__volatile = 0;
	if (g_once_init_enter (&lib_gamepad_linux_raw_gamepad_monitor_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (LibGamepadLinuxRawGamepadMonitorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) lib_gamepad_linux_raw_gamepad_monitor_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (LibGamepadLinuxRawGamepadMonitor), 0, (GInstanceInitFunc) lib_gamepad_linux_raw_gamepad_monitor_instance_init, NULL };
		static const GInterfaceInfo lib_gamepad_raw_gamepad_monitor_info = { (GInterfaceInitFunc) lib_gamepad_linux_raw_gamepad_monitor_lib_gamepad_raw_gamepad_monitor_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
		GType lib_gamepad_linux_raw_gamepad_monitor_type_id;
		lib_gamepad_linux_raw_gamepad_monitor_type_id = g_type_register_static (G_TYPE_OBJECT, "LibGamepadLinuxRawGamepadMonitor", &g_define_type_info, 0);
		g_type_add_interface_static (lib_gamepad_linux_raw_gamepad_monitor_type_id, LIB_GAMEPAD_TYPE_RAW_GAMEPAD_MONITOR, &lib_gamepad_raw_gamepad_monitor_info);
		g_once_init_leave (&lib_gamepad_linux_raw_gamepad_monitor_type_id__volatile, lib_gamepad_linux_raw_gamepad_monitor_type_id);
	}
	return lib_gamepad_linux_raw_gamepad_monitor_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



